{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Infinity is a LuaU object orientated framework & libary, Designed to simplify and Speed the development of an Experience up! I personally use Infinity for all my private & public projects, so if you do come across a problem, it would be awesome if you open an issue on GitHub . Classes The infinity classes, these are a selection of userdata objects which you can call and reference properties from, these userdata objects are composed of unique methods which should help you modularize your programming. Each class is unique in their task and what they must achieve, however, to use a class you must :Extend from one of the class objects, in no case should you ever create or deploy your own Infinity Class as it might not have support for it. Libaries Infinity offers a Bucket-Load of Libaries, which you can access via the Infinity Object! These libaries cover things such as, Perlin Worm Libaries, to important table utility functions like DeepClone. We also use a Net Libary that is built into the fundementals of Infinity Classes, This Net libary is used to send and recieve data with very little instance-manipulation involved. There's alot of awesome libaries to go over, but i'll let you go over them in your own time. Alternatives There are plenty of Frameworks out there to design your experience, however, if you're unsure or don't want to use this framework, below is a list of frameworks that will help you initialize a structure for you experience! Sleitnick/Knit [ Knit is a lightweight framework for Roblox that simplifies communication ... ] Sleitnick/AeroGameFramework [ AeroGameFramework is a Roblox game framework that makes development easy ... ] Quenty/NevermoreEngine [Nevermore is a ModuleScript loader for Roblox, and loads modules by name.] astrealRBLX/volt [ An intuitive and feature-packed Roblox game framework. ]","title":"Home"},{"location":"#classes","text":"The infinity classes, these are a selection of userdata objects which you can call and reference properties from, these userdata objects are composed of unique methods which should help you modularize your programming. Each class is unique in their task and what they must achieve, however, to use a class you must :Extend from one of the class objects, in no case should you ever create or deploy your own Infinity Class as it might not have support for it.","title":"Classes"},{"location":"#libaries","text":"Infinity offers a Bucket-Load of Libaries, which you can access via the Infinity Object! These libaries cover things such as, Perlin Worm Libaries, to important table utility functions like DeepClone. We also use a Net Libary that is built into the fundementals of Infinity Classes, This Net libary is used to send and recieve data with very little instance-manipulation involved. There's alot of awesome libaries to go over, but i'll let you go over them in your own time.","title":"Libaries"},{"location":"#alternatives","text":"There are plenty of Frameworks out there to design your experience, however, if you're unsure or don't want to use this framework, below is a list of frameworks that will help you initialize a structure for you experience! Sleitnick/Knit [ Knit is a lightweight framework for Roblox that simplifies communication ... ] Sleitnick/AeroGameFramework [ AeroGameFramework is a Roblox game framework that makes development easy ... ] Quenty/NevermoreEngine [Nevermore is a ModuleScript loader for Roblox, and loads modules by name.] astrealRBLX/volt [ An intuitive and feature-packed Roblox game framework. ]","title":"Alternatives"},{"location":"pages/change/","text":"","title":"Change"},{"location":"pages/infinity/","text":"","title":"Infinity"},{"location":"pages/installation/","text":"There are two supported ways to install Infinity. For our examples, We'll install Infinity to ReplicatedStorage . In Practice, it's okay to install Infinity anywhere in your experience. Installing to Roblox Studio Download the latest RBXM File from GitHub Releases Insert the model into Studio ( DevForum Response ) Move the model into a suitable location such as ReplicatedStorage Installing to the Filesystem Download the latest Zip Archive from GitHub Releases Extract the Source folder from the Zip Archive into your codebase Rename the Source folder to Infinity You can use a plugin such as Rojo to Sync changes to Studio","title":"Installation"},{"location":"pages/installation/#installing-to-roblox-studio","text":"Download the latest RBXM File from GitHub Releases Insert the model into Studio ( DevForum Response ) Move the model into a suitable location such as ReplicatedStorage","title":"Installing to Roblox Studio"},{"location":"pages/installation/#installing-to-the-filesystem","text":"Download the latest Zip Archive from GitHub Releases Extract the Source folder from the Zip Archive into your codebase Rename the Source folder to Infinity You can use a plugin such as Rojo to Sync changes to Studio","title":"Installing to the Filesystem"},{"location":"pages/setup/","text":"Start Infinity Create a new Script Object and parent it to ServerScriptService in Roblox Studio or Via your third party syncing program: -- // Services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- // Variables local Infinity = require ( ReplicatedStorage . Infinity ) -- // Load Modules -- this is just a basic module-loader. You can advance this by creating module components, and futher, singletons and so on. -- the reason we introduce a module-loader is because we call :Initialize below, We need to set up a game before we Initialize Infinity. -- hence why we call our Modules to create their classes and such before we Initialize Infinity. for _ , Module in ipairs ( script : GetChildren ()) do require ( Module ) end -- // Init Infinity : Initialize (): Catch ( warn ) Context is important! It is very important that you first require and initialize infinity on the server before attempting to do so on the client, more about this is discussed below under Context Matters Initialization & Process When you first require the Infinity Module, a series of steps are taken to ensure the framework is set up and prepared for what the game damands. Context Matters The difference between Server-Client is massive, and when it comes to Infinity, It is very important too. The client depends on the server for a multitude of things, not just it's NetworkClasses. Ensure that you've loaded the Server-Framework before you load the Client-Framework. The Client-Framework will yield any thread calling Infinity until the server has been :Initialized Pre-Initialization Infinity before initialization is essentially a table, wrapped as a UserData, You can add and remove things without issue. Infinity at this stage should be used to add custom variables, tables, and references you might use in the future, such as Global Game Settings. Table Contents are Frozen Anything that is added to this Infinity Table will be locked in place when the call :Initialize is made, attempting to edit or modify Infinity at that stage will result in an error. Post-Initialization This is when your classes finally become classes, Each class you've made will finally be added to the Infinity Object, Allowing you to reference a class by doing the following: local Infinity = require ( game [ \"...\" ]. Infinity ) Infinity : Initialize (): Then ( function () print ( Infinity . MyClass ) end ) Now, there's a critical problem we have right now, is that, what if our classes require, a different class. Well, Infinity builds Methods & Events into these classes, When you call :Initialize on Infinity, if a class has the function Initialize then this function will be fired. local Infinity = require ( game [ \"...\" ]. Infinity ) local ClassObject = Infinity . PublicClass : Extend ( \"MyClass\" ) function ClassObject : Initialized () warn ( self . Name , \"Was Initialized!\" ) end Infinity : Initialize (): Then ( function () print ( Infinity . MyClass ) end )","title":"Setup"},{"location":"pages/setup/#start-infinity","text":"Create a new Script Object and parent it to ServerScriptService in Roblox Studio or Via your third party syncing program: -- // Services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- // Variables local Infinity = require ( ReplicatedStorage . Infinity ) -- // Load Modules -- this is just a basic module-loader. You can advance this by creating module components, and futher, singletons and so on. -- the reason we introduce a module-loader is because we call :Initialize below, We need to set up a game before we Initialize Infinity. -- hence why we call our Modules to create their classes and such before we Initialize Infinity. for _ , Module in ipairs ( script : GetChildren ()) do require ( Module ) end -- // Init Infinity : Initialize (): Catch ( warn ) Context is important! It is very important that you first require and initialize infinity on the server before attempting to do so on the client, more about this is discussed below under Context Matters","title":"Start Infinity"},{"location":"pages/setup/#initialization-process","text":"When you first require the Infinity Module, a series of steps are taken to ensure the framework is set up and prepared for what the game damands.","title":"Initialization &amp; Process"},{"location":"pages/setup/#context-matters","text":"The difference between Server-Client is massive, and when it comes to Infinity, It is very important too. The client depends on the server for a multitude of things, not just it's NetworkClasses. Ensure that you've loaded the Server-Framework before you load the Client-Framework. The Client-Framework will yield any thread calling Infinity until the server has been :Initialized","title":"Context Matters"},{"location":"pages/setup/#pre-initialization","text":"Infinity before initialization is essentially a table, wrapped as a UserData, You can add and remove things without issue. Infinity at this stage should be used to add custom variables, tables, and references you might use in the future, such as Global Game Settings. Table Contents are Frozen Anything that is added to this Infinity Table will be locked in place when the call :Initialize is made, attempting to edit or modify Infinity at that stage will result in an error.","title":"Pre-Initialization"},{"location":"pages/setup/#post-initialization","text":"This is when your classes finally become classes, Each class you've made will finally be added to the Infinity Object, Allowing you to reference a class by doing the following: local Infinity = require ( game [ \"...\" ]. Infinity ) Infinity : Initialize (): Then ( function () print ( Infinity . MyClass ) end ) Now, there's a critical problem we have right now, is that, what if our classes require, a different class. Well, Infinity builds Methods & Events into these classes, When you call :Initialize on Infinity, if a class has the function Initialize then this function will be fired. local Infinity = require ( game [ \"...\" ]. Infinity ) local ClassObject = Infinity . PublicClass : Extend ( \"MyClass\" ) function ClassObject : Initialized () warn ( self . Name , \"Was Initialized!\" ) end Infinity : Initialize (): Then ( function () print ( Infinity . MyClass ) end )","title":"Post-Initialization"},{"location":"pages/classes/netClass/","text":"","title":"Network Class"},{"location":"pages/classes/privateClass/","text":"","title":"Private Class"},{"location":"pages/classes/proxyClass/","text":"","title":"Proxy Class"},{"location":"pages/classes/publicClass/","text":"","title":"Public Class"},{"location":"pages/classes/staticClass/","text":"","title":"Static Class"},{"location":"pages/libs/adornee/","text":"","title":"Adornee"},{"location":"pages/libs/hooks/","text":"","title":"Hooks"},{"location":"pages/libs/iter/","text":"","title":"Iter"},{"location":"pages/libs/maid/","text":"","title":"Maid"},{"location":"pages/libs/math/","text":"","title":"Math"},{"location":"pages/libs/net/","text":"","title":"Net"},{"location":"pages/libs/promise/","text":"","title":"Promise"},{"location":"pages/libs/proxy/","text":"","title":"Proxy"},{"location":"pages/libs/signal/","text":"","title":"Signal"},{"location":"pages/libs/state/","text":"","title":"State"},{"location":"pages/libs/table/","text":"","title":"Table"},{"location":"pages/libs/timer/","text":"","title":"Timer"},{"location":"pages/libs/utils/","text":"","title":"Utils"}]}