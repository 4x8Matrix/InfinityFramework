{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Infinity is a LuaU game framework designed for the Roblox Engine! Infinity's purpose as a game framework is to speed up the development of your Roblox-Experience, with a ton of different libaries, singletons and classes, developers can deploy advanced systems and manipulate them through Infinity easily! This framework combines both ECS and OOP principles, The core infinity object itself uses these principles to create a reliable registry, that'll allow you to access public classes and so on. If you encounter problems with Infinity, please be sure to let me know! Discord GitHub Warning Infinity is still in it's early stages, I would stay away from using this framework for big-projects. There are plenty of frameworks out there to help you design your experience, however, if you don't want to use Infinity, below is a list of frameworks that will help you design your game instead! Sleitnick/Knit [ Knit is a lightweight framework for Roblox that simplifies communication ... ] Sleitnick/AeroGameFramework [ AeroGameFramework is a Roblox game framework that makes development easy ... ] Quenty/NevermoreEngine [Nevermore is a ModuleScript loader for Roblox, and loads modules by name.] astrealRBLX/volt [ An intuitive and feature-packed Roblox game framework. ]","title":"Home"},{"location":"InfinityPage/","text":"Infinity Registry The Infinity registy is essentially a dictionary holding alot of key classes, properties, methods and so on. The Infinity module itself is the Registry, once you initialize infinity, classes will be added to infinity directly, allowing you to access Infinity classes like; Script #1 local Class = Infinity . PublicClass : Extend ( \"MyPublicClass\" ) Class . Variable = \"Hello, World!\" Script #2 -- This hooks gets invoked when Infinity gets initialized, allowing us to connect to the infinity Init-Pipeline Infinity . Hooks : BindHook ( \"Init\" , function () local MyClass = Infinity . MyPublicClass print ( MyClass . Variable ) end ) Important Below is an example of what you should NOT do. -- This hooks gets invoked when Infinity gets initialized, allowing us to connect to the infinity Init-Pipeline local MyClass = Infinity . MyPublicClass print ( MyClass . Variable ) -- > This will error, Indexing nil 'Variable' -- Infinity hasn't started yet, any `PublicClass` objects aren't in the Infinity Registry Infinity Model Infinity Require Model The Infinity Require model explains what hapens when you first require the Infinity Module, There's alot more going on than what you'd assume. Warning Infinity that is called on the client will yield until it's master (Server Infinity) is Initialized, If your script isn't loading or Infinity isn't loading, make sure that your server Infinity is Initialized and loaded! Infinity Clients need the Master in order to recieve critical information about NetClasses and so on. Infinity Initialize Model The Infinity initialize model is very different from the Require Model, This model represents what happens when you call :Initialize on the Infinity object. Infinity API Infinity Methods Infinity.Initialize Infinity : Initialize (...: any ) -> Infinity . Promise This is the function which will initialize infinity and it's classes. It is required that you register all required modules before calling this function, after you call this function classes such as PublicClass & NetworkClass cannot be initiated. This method will also lock the Infinity Registry, attempting to write to Infinity will result in an error, however you were able too in it's pre-initialized state. For an example, I'll be a script I use for most of my Infinity-Client tests. -- // Services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local StarterGui = game : GetService ( \"StarterGui\" ) -- // Variables local ClockInit = os.clock () local Infinity = require ( ReplicatedStorage : WaitForChild ( \"Infinity\" )) -- // Load FileSystem -- LoadModules loops through the objects children, requiring them -- if the child returns a function, this childs function is executed with -- the one argument of infinitu itself. Infinity . FileSystem : LoadModules ( script . Singletons ) Infinity . FileSystem : LoadModules ( script . Components ) Infinity . FileSystem : LoadModules ( script . Interface ) Infinity . FileSystem : LoadModules ( script . Logic ) -- // Init Infinity : Initialize (): Then ( function () StarterGui : SetCoreGuiEnabled ( Enum . CoreGuiType . All , false ) Infinity . Console : Log (( \"Client Initialized [%sms]\" ): format ( os.clock () - ClockInit )) end ): Catch ( function ( Promise , Exception ) Infinity . Console : Warn ( Exception ) -- At this point you can impliment a custom system to teleport you into the same game -- Or have a backup system ready to deploy if this system fails. end ) Infinity Properties Infinity.IsServer Infinity . IsSever --> Bool Aliase for RunService:IsServer() Infinity.IsStudio Infinity . IsStudio --> Bool Aliase for RunService:IsStudio()","title":"Infinity"},{"location":"InfinityPage/#infinity-registry","text":"The Infinity registy is essentially a dictionary holding alot of key classes, properties, methods and so on. The Infinity module itself is the Registry, once you initialize infinity, classes will be added to infinity directly, allowing you to access Infinity classes like; Script #1 local Class = Infinity . PublicClass : Extend ( \"MyPublicClass\" ) Class . Variable = \"Hello, World!\" Script #2 -- This hooks gets invoked when Infinity gets initialized, allowing us to connect to the infinity Init-Pipeline Infinity . Hooks : BindHook ( \"Init\" , function () local MyClass = Infinity . MyPublicClass print ( MyClass . Variable ) end ) Important Below is an example of what you should NOT do. -- This hooks gets invoked when Infinity gets initialized, allowing us to connect to the infinity Init-Pipeline local MyClass = Infinity . MyPublicClass print ( MyClass . Variable ) -- > This will error, Indexing nil 'Variable' -- Infinity hasn't started yet, any `PublicClass` objects aren't in the Infinity Registry","title":"Infinity Registry"},{"location":"InfinityPage/#infinity-model","text":"","title":"Infinity Model"},{"location":"InfinityPage/#infinity-require-model","text":"The Infinity Require model explains what hapens when you first require the Infinity Module, There's alot more going on than what you'd assume. Warning Infinity that is called on the client will yield until it's master (Server Infinity) is Initialized, If your script isn't loading or Infinity isn't loading, make sure that your server Infinity is Initialized and loaded! Infinity Clients need the Master in order to recieve critical information about NetClasses and so on.","title":"Infinity Require Model"},{"location":"InfinityPage/#infinity-initialize-model","text":"The Infinity initialize model is very different from the Require Model, This model represents what happens when you call :Initialize on the Infinity object.","title":"Infinity Initialize Model"},{"location":"InfinityPage/#infinity-api","text":"","title":"Infinity API"},{"location":"InfinityPage/#infinity-methods","text":"","title":"Infinity Methods"},{"location":"InfinityPage/#infinityinitialize","text":"Infinity : Initialize (...: any ) -> Infinity . Promise This is the function which will initialize infinity and it's classes. It is required that you register all required modules before calling this function, after you call this function classes such as PublicClass & NetworkClass cannot be initiated. This method will also lock the Infinity Registry, attempting to write to Infinity will result in an error, however you were able too in it's pre-initialized state. For an example, I'll be a script I use for most of my Infinity-Client tests. -- // Services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local StarterGui = game : GetService ( \"StarterGui\" ) -- // Variables local ClockInit = os.clock () local Infinity = require ( ReplicatedStorage : WaitForChild ( \"Infinity\" )) -- // Load FileSystem -- LoadModules loops through the objects children, requiring them -- if the child returns a function, this childs function is executed with -- the one argument of infinitu itself. Infinity . FileSystem : LoadModules ( script . Singletons ) Infinity . FileSystem : LoadModules ( script . Components ) Infinity . FileSystem : LoadModules ( script . Interface ) Infinity . FileSystem : LoadModules ( script . Logic ) -- // Init Infinity : Initialize (): Then ( function () StarterGui : SetCoreGuiEnabled ( Enum . CoreGuiType . All , false ) Infinity . Console : Log (( \"Client Initialized [%sms]\" ): format ( os.clock () - ClockInit )) end ): Catch ( function ( Promise , Exception ) Infinity . Console : Warn ( Exception ) -- At this point you can impliment a custom system to teleport you into the same game -- Or have a backup system ready to deploy if this system fails. end )","title":"Infinity.Initialize"},{"location":"InfinityPage/#infinity-properties","text":"","title":"Infinity Properties"},{"location":"InfinityPage/#infinityisserver","text":"Infinity . IsSever --> Bool Aliase for RunService:IsServer()","title":"Infinity.IsServer"},{"location":"InfinityPage/#infinityisstudio","text":"Infinity . IsStudio --> Bool Aliase for RunService:IsStudio()","title":"Infinity.IsStudio"},{"location":"InstallPage/","text":"There are two supported ways to install Infinity. For our examples, We will deploy the Infinity Framework to ReplicatedStorage . This is just an example, You can install Infinity anywhere in your game, however somewhere where both server & client have access is important. Roblox Studio Installation Download the latest RBXM File from GitHub Releases Insert the model into Studio ( DevForum Tutorial ) Move the model into a suitable location such as ReplicatedStorage Filesystem Installation Download the latest Zip Archive from GitHub Releases Extract the Source folder from the Zip Archive into your workspace Rename the Source folder to Infinity Sync Filesystem To sync the changes on your local system, you should use plugins such as Rojo . This plugin will help sync changes from your local system to a studio instance!","title":"Installation"},{"location":"InstallPage/#roblox-studio-installation","text":"Download the latest RBXM File from GitHub Releases Insert the model into Studio ( DevForum Tutorial ) Move the model into a suitable location such as ReplicatedStorage","title":"Roblox Studio Installation"},{"location":"InstallPage/#filesystem-installation","text":"Download the latest Zip Archive from GitHub Releases Extract the Source folder from the Zip Archive into your workspace Rename the Source folder to Infinity","title":"Filesystem Installation"},{"location":"InstallPage/#sync-filesystem","text":"To sync the changes on your local system, you should use plugins such as Rojo . This plugin will help sync changes from your local system to a studio instance!","title":"Sync Filesystem"},{"location":"SetupPage/","text":"Once Infinity is installed, it's quite simple to take advantage of, to reference Infinity you're going to have to require the Infinity Source/Module. -- // Services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- // Variables local Infinity = require ( ReplicatedStorage : WaitForChild ( \"Infinity\" )) From here, we can access libaries, classes and singletons! As an example, I'll be show off how to use the custom iteration Infinity allows you to do! local Iteration = Infinity . Iter : FromVararg ( 1 , 2 , 3 , \"Hello\" , \"World\" ) for Value in Iteration do warn ( \"Value:\" , Value ) warn ( \"Index:\" , Iteration : GetIndex ()) warn ( \"Key:\" , Iteration : GetKey ()) end The following code will interpret any arguments passed into the method FromVararg and Iterate though them. The iteration object also accepts roblox-pages as an input, allowing you to iterate through global leaderboards and so on. Extending Infinity classes is also a feature which developers can take advantage of, When you extend a class, you inherit that classes properties, methods and so on. Allowing you to create an extention from that class. Below is an example of how we would create virtual boat classes that we can manipulate! -- // Classes local BoatSingleton = Infinity . PublicClass : Extend ( \"BoatSingleton\" ) -- This would be our Singleton/Service local GenericBoat = Infinity . PrivateClass : Extend ( \"BoatObject\" ) -- This would be our Component -- // GenericBoat Signals GenericBoat : NewSignal ( \"CaptainChanged\" ) -- // GenericBoat Methods function GenericBoat : SetCaptain ( Player ) self . Captain = Player self . CaptainChanged : Fire ( Player ) -- Whenever we call NewSignal, NewSymbol etc, the result will always be added to the class. -- This way we do not need to manually assign it! end function GenericBoat : GetModelRoot () -- self.Model refers to the Model we added in our :OnExtend function below! return self . Model . PrimaryPart end function GenericBoat : OnExtended ( Class , Model ) -- This function is called when :Extend is called on our `GenericBoat` object -- We get the new class, and any arguments given through the :Extend function! Class . Model = Model end -- // BoatSingleton Methods function BoatSingleton : CreateVirtualBoat ( BoatModel ) -- The BoatModel argument will be the 2nd argument passed into the :OnExtended function above! local OurBoatObject = GenericBoat : Extend ( BoatModel ) print ( OurBoatObject : GetModelRoot ()) -- > BoatModel's Primary Part return OurBoatObject end Note The code above isn't a complete example of a boat system, there's alot more which could be put into it.","title":"Setup"},{"location":"InfinityPages/InfinityClasses/BaseClass/","text":"The 'BaseClass' is the base of each class, every Infinity class inherits its functions, properties and so on from this class. Warning This class is not designed to be constructed or extended from, this class is essentially a structure for other classes, in no way is it meant to represent it's own class. Event Register Some classes are subjected to recieve events, the purpose of this is to make your life as a develop easier. To recieve an event, you'll have to create a function within the class. Infinity will then invoke this function when that specific event is fired. The events are as follows. Heartbeat function Class : Heartbeat (...) self : CalculateAbc (...) end The Heartbeat function will be invoked each Heartbeat Infomation This event only applies to classes inside of the Infinity-Event register, classes such as StaticClass will not recieve these events. Warning Infinity Events are Single-Threaded, on each new render, it will go through all classes with the RenderStepped function, and it will run them [ No thread assigned to it. ] Stepped function Class : Stepped (...) self : CalculateAbc (...) end The Heartbeat function will be invoked each RenderStepped Infomation This event only applies to classes inside of the Infinity-Event register, classes such as StaticClass will not recieve these events. Warning Infinity Events are Single-Threaded, on each new render, it will go through all classes with the RenderStepped function, and it will run them [ No thread assigned to it. ] OnExtended function Class : OnExtended ( SubClass : < Infinity . BaseClass > Infinity . Class , ...: any ) SubClass . Name = select ( 1 , ...) end Class : The class which is being extended from SubClass : The class which is being created from the Extend function ... : Any variables passed into the Extend function. OnExtended is a special function to allow a developer to edit sub-classes which are created from our Class object. This class will not yet be defined, so a developer can access and manipulate the class in whatever way they would like too. Initialize function Class : Initialize (...) self . Abc = 1 print ( \"Whoo Hoo!\" ) end ... : Variables passed into the Infinity:Initialize function. This method will be invoked when Infinity is Initialized, At this point you can access all public classes and so on, allowing you to define infinity services and so on within the class. FullName Subjection Objects subjected to being a FullName will have their strings parsed in a unique way, The string will be split by it's periods \" . \" and a new table will be added into the previous table (if there is no previous table, then the previous table will be the class itself). local Class = Infinity . PrivateClass : Extend () Class : NewState ( \"StatesTable.State123\" , \"StateValue\" ) -- State123 is the Key. -- StatesTable is the newly created table. -- Infinity will create a new table called StatesTable, -- Infinity will construct a new State object with the value of StateValue -- Infinity will set StatesTable.State123 as the result of that object print ( Class . StatesTable ) -- > Table { State } -- Things like this are awesome for Signals and so on. Class : NewSignal ( \"GameEvents.MainEvent\" ) BaseClass API BaseClass Methods Class.NewState ClassObject : NewState ( StateFullName : string , StateValue : any ) --> Infinity.State Helper function used to create a new Infinity state object, the constructed state is added to the class and returned For more information on state objects, look here Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way. Class.NewSignal ClassObject : NewSignal ( SignalFullName : string ) --> Infinity.Signal Helper function used to create a new Infinity signal object, the constructed signal is added to the class and returned For more information on signal objects, look here Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way. Class.NewSymbol ClassObject : NewSymbol ( SymbolFullName : string ) --> userdata Symbols are an interpretation of our roblox enumeration system, each class has the ability to assign custom symbols to itself, these symbols represent class enumerations, for example they could represent a class state, weather it's active or dead. Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way. Class.IsSuper ClassObject : IsSuper ( SuperClass : < Infinity . BaseClass > Infinity . Class ) --> bool Returns if the super given in the first argument is the super of the current class object Class.Maid ClassObject : Maid () -- > Infinity.Maid Creates a maid object to handle and clean up the class, to access the maid object you'll have to either reference it as a maid object or index the class with 'MaidObject' When this class is destroyed, the method :Destroy will be called on the maid, destroying all connections etc you have connected to the maid object. Class.Await ClassObject : Await ( ObjectName : string ) -- > Object Await yields the current thread until an object has been found inside of the class, this can be used to pause execution until a flag has been met on an object and so forth. Class.SetClassName ClassObject : SetClassName ( ClassName : string ) Set the type & name of the class to the given string argument. Class.GetMethods ClassObject : GetMethods () -- > { MethodName: Method } Returns a dictionary of methods/functions that have been added to the class object. Class.Destroy ClassObject : Destroy () Initiates an iteration through the class object, destroying, disconnecting and removing objects within the class itself. Warning When calling this method, there is a chance you can break all sub-classes which have been extended from this class. References up-stream can be broken by removing them from this class. Class.Extend ClassObject : Extend (... < any > ) -- > Sub-Class of ClassObject This method is used to create extentions of every class inside of the Infinity framework, This function is added to each Class and can be called on each class, allowing you to infinitly extend and create components from other components. The result of an extend is a subclass of the class you just extended from, everything from ClassObject will be inherited into this new SubClass which will reference functions and so on from our previous classes. Information When you extend a class, Infinity does a measure of things to initiate a new sub-class, this includes inheriting values, calling the OnExtended function, and so on. Some classes may require specific arguments when extending from it, for example, PublicClass requires a ClassName argument! BaseClass Properties Class.Type ClassObject . Type --> String Returns the type of Class it is, Ranging from PublicClass to Proxy/Network Class Class.Name ClassObject . Name --> String The name of the class, the name can be set by the class or during the extention of a class. Class.Infinity ClassObject . Infinity --> Infinity A reference to the Infinity Framework, Internal use mostly. Class.Super ClassObject . Infinity --> ClassObject Returns the Super Class to this class.","title":"Base Class"},{"location":"InfinityPages/InfinityClasses/BaseClass/#event-register","text":"Some classes are subjected to recieve events, the purpose of this is to make your life as a develop easier. To recieve an event, you'll have to create a function within the class. Infinity will then invoke this function when that specific event is fired. The events are as follows.","title":"Event Register"},{"location":"InfinityPages/InfinityClasses/BaseClass/#heartbeat","text":"function Class : Heartbeat (...) self : CalculateAbc (...) end The Heartbeat function will be invoked each Heartbeat Infomation This event only applies to classes inside of the Infinity-Event register, classes such as StaticClass will not recieve these events. Warning Infinity Events are Single-Threaded, on each new render, it will go through all classes with the RenderStepped function, and it will run them [ No thread assigned to it. ]","title":"Heartbeat"},{"location":"InfinityPages/InfinityClasses/BaseClass/#stepped","text":"function Class : Stepped (...) self : CalculateAbc (...) end The Heartbeat function will be invoked each RenderStepped Infomation This event only applies to classes inside of the Infinity-Event register, classes such as StaticClass will not recieve these events. Warning Infinity Events are Single-Threaded, on each new render, it will go through all classes with the RenderStepped function, and it will run them [ No thread assigned to it. ]","title":"Stepped"},{"location":"InfinityPages/InfinityClasses/BaseClass/#onextended","text":"function Class : OnExtended ( SubClass : < Infinity . BaseClass > Infinity . Class , ...: any ) SubClass . Name = select ( 1 , ...) end Class : The class which is being extended from SubClass : The class which is being created from the Extend function ... : Any variables passed into the Extend function. OnExtended is a special function to allow a developer to edit sub-classes which are created from our Class object. This class will not yet be defined, so a developer can access and manipulate the class in whatever way they would like too.","title":"OnExtended"},{"location":"InfinityPages/InfinityClasses/BaseClass/#initialize","text":"function Class : Initialize (...) self . Abc = 1 print ( \"Whoo Hoo!\" ) end ... : Variables passed into the Infinity:Initialize function. This method will be invoked when Infinity is Initialized, At this point you can access all public classes and so on, allowing you to define infinity services and so on within the class.","title":"Initialize"},{"location":"InfinityPages/InfinityClasses/BaseClass/#fullname-subjection","text":"Objects subjected to being a FullName will have their strings parsed in a unique way, The string will be split by it's periods \" . \" and a new table will be added into the previous table (if there is no previous table, then the previous table will be the class itself). local Class = Infinity . PrivateClass : Extend () Class : NewState ( \"StatesTable.State123\" , \"StateValue\" ) -- State123 is the Key. -- StatesTable is the newly created table. -- Infinity will create a new table called StatesTable, -- Infinity will construct a new State object with the value of StateValue -- Infinity will set StatesTable.State123 as the result of that object print ( Class . StatesTable ) -- > Table { State } -- Things like this are awesome for Signals and so on. Class : NewSignal ( \"GameEvents.MainEvent\" )","title":"FullName Subjection"},{"location":"InfinityPages/InfinityClasses/BaseClass/#baseclass-api","text":"","title":"BaseClass API"},{"location":"InfinityPages/InfinityClasses/BaseClass/#baseclass-methods","text":"","title":"BaseClass Methods"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classnewstate","text":"ClassObject : NewState ( StateFullName : string , StateValue : any ) --> Infinity.State Helper function used to create a new Infinity state object, the constructed state is added to the class and returned For more information on state objects, look here Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way.","title":"Class.NewState"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classnewsignal","text":"ClassObject : NewSignal ( SignalFullName : string ) --> Infinity.Signal Helper function used to create a new Infinity signal object, the constructed signal is added to the class and returned For more information on signal objects, look here Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way.","title":"Class.NewSignal"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classnewsymbol","text":"ClassObject : NewSymbol ( SymbolFullName : string ) --> userdata Symbols are an interpretation of our roblox enumeration system, each class has the ability to assign custom symbols to itself, these symbols represent class enumerations, for example they could represent a class state, weather it's active or dead. Info FullName Strings are subject to FullName-Subjection , The string passed into this function will be parsed and handled in a unique way.","title":"Class.NewSymbol"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classissuper","text":"ClassObject : IsSuper ( SuperClass : < Infinity . BaseClass > Infinity . Class ) --> bool Returns if the super given in the first argument is the super of the current class object","title":"Class.IsSuper"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classmaid","text":"ClassObject : Maid () -- > Infinity.Maid Creates a maid object to handle and clean up the class, to access the maid object you'll have to either reference it as a maid object or index the class with 'MaidObject' When this class is destroyed, the method :Destroy will be called on the maid, destroying all connections etc you have connected to the maid object.","title":"Class.Maid"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classawait","text":"ClassObject : Await ( ObjectName : string ) -- > Object Await yields the current thread until an object has been found inside of the class, this can be used to pause execution until a flag has been met on an object and so forth.","title":"Class.Await"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classsetclassname","text":"ClassObject : SetClassName ( ClassName : string ) Set the type & name of the class to the given string argument.","title":"Class.SetClassName"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classgetmethods","text":"ClassObject : GetMethods () -- > { MethodName: Method } Returns a dictionary of methods/functions that have been added to the class object.","title":"Class.GetMethods"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classdestroy","text":"ClassObject : Destroy () Initiates an iteration through the class object, destroying, disconnecting and removing objects within the class itself. Warning When calling this method, there is a chance you can break all sub-classes which have been extended from this class. References up-stream can be broken by removing them from this class.","title":"Class.Destroy"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classextend","text":"ClassObject : Extend (... < any > ) -- > Sub-Class of ClassObject This method is used to create extentions of every class inside of the Infinity framework, This function is added to each Class and can be called on each class, allowing you to infinitly extend and create components from other components. The result of an extend is a subclass of the class you just extended from, everything from ClassObject will be inherited into this new SubClass which will reference functions and so on from our previous classes. Information When you extend a class, Infinity does a measure of things to initiate a new sub-class, this includes inheriting values, calling the OnExtended function, and so on. Some classes may require specific arguments when extending from it, for example, PublicClass requires a ClassName argument!","title":"Class.Extend"},{"location":"InfinityPages/InfinityClasses/BaseClass/#baseclass-properties","text":"","title":"BaseClass Properties"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classtype","text":"ClassObject . Type --> String Returns the type of Class it is, Ranging from PublicClass to Proxy/Network Class","title":"Class.Type"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classname","text":"ClassObject . Name --> String The name of the class, the name can be set by the class or during the extention of a class.","title":"Class.Name"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classinfinity","text":"ClassObject . Infinity --> Infinity A reference to the Infinity Framework, Internal use mostly.","title":"Class.Infinity"},{"location":"InfinityPages/InfinityClasses/BaseClass/#classsuper","text":"ClassObject . Infinity --> ClassObject Returns the Super Class to this class.","title":"Class.Super"},{"location":"InfinityPages/InfinityClasses/NetworkClass/","text":"A NetworkClass is a very special class used to breach the Client-Server, Server-Client relationship, this class will allow you to connect signals, functions, properties and so on, so that the client can access them. This Class is alot like the PublicClass, this class will be added to the infinity registry, You can read more about that here! Information This class is in the infinity event register, meaning this class will recieve events such as Stepped , Heartbeat , and so forth. You can read more about this over here! The events fired here are context-bound, Server's Heartbeat wont be sent to the client. NetworkClass Model When a Client joins the game, they will recieve a packet holding important information to structure and replicate NetworkClasses to their Infinity client, from here on the client will create a ProxyClass [Internal Infinity Class] which will be used to replicate functions, signals and so on to the server. This ProxyClass represents the Server-NetworkClass, Call functions and so on as if you were calling the server. This ProxyClass respects the __namecall metamethod when it comes to functions, If you use :, the server will recieve self and so on. A list of objects which can be replicated through the Infinity Proxy/Net class is: Roblox Objects Roblox Types Infinity Signal Warning NetworkClasses are Synced only when a Client joins the game, Attempting to Modify the NetworkClass after Infinitity is Initialized will result in errors. NetworkClass API NetworkClass Methods Class.Fire ClassObject : Fire ( FunctionName ) This function will invoke functions which have been added to the client proxy class. however, if there is no function within this proxy class, nothing will be invoked. ServerScript local Class = Infinity . NetworkClass : Extend ( \"ClassObject\" ) function Class . Client : InvokeMethodAbc ( Player ) Class : Fire ( \"Abc\" , 123 ) end LocalScript Infinity . Hooks : BindHook ( \"Init\" , function () local NetworkClass = Infinity . ClassObject function NetworkClass . Abc (...) warn ( \"Yes! We got:\" , ...) end NetworkClass : InvokeMethodAbc () end ) NetworkClass Properties Class.Client ClassObject . Client -- > Table This table represents what will be replicated to the client, we don't want to share our entire class, that could lead to some really big issues with security and so on. So we dedicate a Table for Client-Replication. Functions, Signals and so on not added to this table will not be recieved on the client. Class.Function ClassObject . Client -- > Infinity.Net.Function This is the primary net function used to internally communicate things to the client. Warning Changing the behaviour of this function can lead to problems with the class itself working, However if you want to write custom logic for a Net class, this is what you'll have to manipulate. Class.Event ClassObject . Client -- > Infinity.Net.Event This is the primary net event used to internally communicate things to the client. Warning Changing the behaviour of this function can lead to problems with the class itself working, However if you want to write custom logic for a Net class, this is what you'll have to manipulate. Example ServerScript local Class = Infinity . NetworkClass : Extend ( \"ServerTimeService\" ) Class : NewSignal ( \"Client.UpdatedTime\" ) -- self refers to the class object, not the Client table. Behaviour has changed slightly there. function Class . Client : GetServerTime ( Player ) self . Time = tick () self . Client . UpdatedTime : Fire ( self . Tick ) return self . Time end LocalScript Infinity . Hooks : BindHook ( \"Init\" , function () local NetworkClass = Infinity . ServerTimeService while true do warn ( \"Delay:\" , tick () - NetworkClass : GetServerTime ()) task . wait ( 5 ) end end )","title":"Network Class"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#networkclass-model","text":"When a Client joins the game, they will recieve a packet holding important information to structure and replicate NetworkClasses to their Infinity client, from here on the client will create a ProxyClass [Internal Infinity Class] which will be used to replicate functions, signals and so on to the server. This ProxyClass represents the Server-NetworkClass, Call functions and so on as if you were calling the server. This ProxyClass respects the __namecall metamethod when it comes to functions, If you use :, the server will recieve self and so on. A list of objects which can be replicated through the Infinity Proxy/Net class is: Roblox Objects Roblox Types Infinity Signal Warning NetworkClasses are Synced only when a Client joins the game, Attempting to Modify the NetworkClass after Infinitity is Initialized will result in errors.","title":"NetworkClass Model"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#networkclass-api","text":"","title":"NetworkClass API"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#networkclass-methods","text":"","title":"NetworkClass Methods"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#classfire","text":"ClassObject : Fire ( FunctionName ) This function will invoke functions which have been added to the client proxy class. however, if there is no function within this proxy class, nothing will be invoked. ServerScript local Class = Infinity . NetworkClass : Extend ( \"ClassObject\" ) function Class . Client : InvokeMethodAbc ( Player ) Class : Fire ( \"Abc\" , 123 ) end LocalScript Infinity . Hooks : BindHook ( \"Init\" , function () local NetworkClass = Infinity . ClassObject function NetworkClass . Abc (...) warn ( \"Yes! We got:\" , ...) end NetworkClass : InvokeMethodAbc () end )","title":"Class.Fire"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#networkclass-properties","text":"","title":"NetworkClass Properties"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#classclient","text":"ClassObject . Client -- > Table This table represents what will be replicated to the client, we don't want to share our entire class, that could lead to some really big issues with security and so on. So we dedicate a Table for Client-Replication. Functions, Signals and so on not added to this table will not be recieved on the client.","title":"Class.Client"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#classfunction","text":"ClassObject . Client -- > Infinity.Net.Function This is the primary net function used to internally communicate things to the client. Warning Changing the behaviour of this function can lead to problems with the class itself working, However if you want to write custom logic for a Net class, this is what you'll have to manipulate.","title":"Class.Function"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#classevent","text":"ClassObject . Client -- > Infinity.Net.Event This is the primary net event used to internally communicate things to the client. Warning Changing the behaviour of this function can lead to problems with the class itself working, However if you want to write custom logic for a Net class, this is what you'll have to manipulate.","title":"Class.Event"},{"location":"InfinityPages/InfinityClasses/NetworkClass/#example","text":"ServerScript local Class = Infinity . NetworkClass : Extend ( \"ServerTimeService\" ) Class : NewSignal ( \"Client.UpdatedTime\" ) -- self refers to the class object, not the Client table. Behaviour has changed slightly there. function Class . Client : GetServerTime ( Player ) self . Time = tick () self . Client . UpdatedTime : Fire ( self . Tick ) return self . Time end LocalScript Infinity . Hooks : BindHook ( \"Init\" , function () local NetworkClass = Infinity . ServerTimeService while true do warn ( \"Delay:\" , tick () - NetworkClass : GetServerTime ()) task . wait ( 5 ) end end )","title":"Example"},{"location":"InfinityPages/InfinityClasses/PrivateClass/","text":"About A BoatClass represents a class which will not be added to the Infinity registry, allowing you to create classes that are not attached, yet still recieve things such as events from Infinity. This class is not effected by the Infinity Initialization pipeline, however will still recieve events such as Initialize This classes best use-case would be creating components, you would use this class to create unique objects which can be used to achieve a multitude of things. Information This class is in the infinity event register, meaning this class will recieve events such as Stepped , Heartbeat , and so forth. You can read more about this over here! Example Information ModuleScript's Parent is Script#1. Therefore allowing Infinity.FileSystem:LoadModules to require the ModuleScript! ModuleScript local BoatClass = Infinity . BoatClass : Extend ( \"MyCoolClass\" ) -- It is suggested that you define a name. BoatClass : NewSignal ( \"DriverChanged\" ) function BoatClass : SetDriver ( Player ) self . Driver = Player self . DriverChanged : Fire ( Player ) end return BoatClass Script #1 local BoatClass = require ( script . ModuleScript ) local BoatObject = BoatClass : Extend () BoatObject : SetDriver ( game . Players . AsynchronousMatrix )","title":"Private Class"},{"location":"InfinityPages/InfinityClasses/PrivateClass/#about","text":"A BoatClass represents a class which will not be added to the Infinity registry, allowing you to create classes that are not attached, yet still recieve things such as events from Infinity. This class is not effected by the Infinity Initialization pipeline, however will still recieve events such as Initialize This classes best use-case would be creating components, you would use this class to create unique objects which can be used to achieve a multitude of things. Information This class is in the infinity event register, meaning this class will recieve events such as Stepped , Heartbeat , and so forth. You can read more about this over here!","title":"About"},{"location":"InfinityPages/InfinityClasses/PrivateClass/#example","text":"Information ModuleScript's Parent is Script#1. Therefore allowing Infinity.FileSystem:LoadModules to require the ModuleScript! ModuleScript local BoatClass = Infinity . BoatClass : Extend ( \"MyCoolClass\" ) -- It is suggested that you define a name. BoatClass : NewSignal ( \"DriverChanged\" ) function BoatClass : SetDriver ( Player ) self . Driver = Player self . DriverChanged : Fire ( Player ) end return BoatClass Script #1 local BoatClass = require ( script . ModuleScript ) local BoatObject = BoatClass : Extend () BoatObject : SetDriver ( game . Players . AsynchronousMatrix )","title":"Example"},{"location":"InfinityPages/InfinityClasses/PublicClass/","text":"About A PublicClass represents a global, accessable class. When Infinity is Initialized, this class will be added to the Infinity pool, allowing you to reference this class through Infinity, this will allow all of your modules and so on to manipulate the functions, states, signals and so on inside of this class. Warning When you Extend a PublicClass, you have to define a ClassName argument. This is because PublicClasses require a ClassName in order to be added to the infinity registry, without a Name, you would not be able to reference it through Infinity. Information This class is in the infinity event register, meaning this class will recieve events such as Stepped , Heartbeat , and so forth. You can read more about this over here! Example Information ModuleScript's Parent is Script#1. Therefore allowing Infinity.FileSystem:LoadModules to require the ModuleScript! Module Script local Class = Infinity . PublicClass : Extend ( \"ClassName\" ) -- Argument #1: ClassName is really important! -- Just a psuedo class to use as an example Class . Random = math.random function Class : ComputeRandomNumber ( Val0 , Val1 ) return self . Random ( Val0 , Val1 ) end Script #1 local Infinity = require ( game [ \"...\" ]. Infinity ) -- This will require all modules under the parent script. Infinity . FileSystem : LoadModules ( script ) Infinity : Initialize (): Then ( function () local Class = Infinity . ClassName -- This is a reference to our Class-Object we constructed in the ModuleScript print ( Class : ComputeRandomNumber ()) -- We can access that classes functions and so on. end )","title":"Public Class"},{"location":"InfinityPages/InfinityClasses/PublicClass/#about","text":"A PublicClass represents a global, accessable class. When Infinity is Initialized, this class will be added to the Infinity pool, allowing you to reference this class through Infinity, this will allow all of your modules and so on to manipulate the functions, states, signals and so on inside of this class. Warning When you Extend a PublicClass, you have to define a ClassName argument. This is because PublicClasses require a ClassName in order to be added to the infinity registry, without a Name, you would not be able to reference it through Infinity. Information This class is in the infinity event register, meaning this class will recieve events such as Stepped , Heartbeat , and so forth. You can read more about this over here!","title":"About"},{"location":"InfinityPages/InfinityClasses/PublicClass/#example","text":"Information ModuleScript's Parent is Script#1. Therefore allowing Infinity.FileSystem:LoadModules to require the ModuleScript! Module Script local Class = Infinity . PublicClass : Extend ( \"ClassName\" ) -- Argument #1: ClassName is really important! -- Just a psuedo class to use as an example Class . Random = math.random function Class : ComputeRandomNumber ( Val0 , Val1 ) return self . Random ( Val0 , Val1 ) end Script #1 local Infinity = require ( game [ \"...\" ]. Infinity ) -- This will require all modules under the parent script. Infinity . FileSystem : LoadModules ( script ) Infinity : Initialize (): Then ( function () local Class = Infinity . ClassName -- This is a reference to our Class-Object we constructed in the ModuleScript print ( Class : ComputeRandomNumber ()) -- We can access that classes functions and so on. end )","title":"Example"},{"location":"InfinityPages/InfinityClasses/StaticClass/","text":"About The class is essentially as close as you can get to a BaseClass, The class has no events and no special features inherited from Infinity. This class is essentially the BaseClass, Therefore this class would also be a good candidate for a custom class, handled by your own scripts you could serialize a StaticClass into a Component, System, Service etc. Static Class is designed to be a clean slate for you to do what you want with it. For example, a reason why you might want to use this class is for a libary, libaries contain static methods and variables which you can reference at a later date, this class would be a good candidate for that. Example Script #1 local StaticClass = Infinity . StaticClass : Extend () StaticClass . Abc = 123 StaticClass . Abc123 = function () end Infinity . StaticLibary = StaticClass Script #2 Infinity . Hooks : BindHook ( \"Init\" , function () local Class = Infinity . StaticLibary Class . Abc123 () end )","title":"Static Class"},{"location":"InfinityPages/InfinityClasses/StaticClass/#about","text":"The class is essentially as close as you can get to a BaseClass, The class has no events and no special features inherited from Infinity. This class is essentially the BaseClass, Therefore this class would also be a good candidate for a custom class, handled by your own scripts you could serialize a StaticClass into a Component, System, Service etc. Static Class is designed to be a clean slate for you to do what you want with it. For example, a reason why you might want to use this class is for a libary, libaries contain static methods and variables which you can reference at a later date, this class would be a good candidate for that.","title":"About"},{"location":"InfinityPages/InfinityClasses/StaticClass/#example","text":"Script #1 local StaticClass = Infinity . StaticClass : Extend () StaticClass . Abc = 123 StaticClass . Abc123 = function () end Infinity . StaticLibary = StaticClass Script #2 Infinity . Hooks : BindHook ( \"Init\" , function () local Class = Infinity . StaticLibary Class . Abc123 () end )","title":"Example"},{"location":"InfinityPages/InfinityLibaries/AdorneeLibary/","text":"AdorneeLibary Methods AdorneeLibary.Sphere AdorneeLibary.Arrow","title":"Adornee"},{"location":"InfinityPages/InfinityLibaries/AdorneeLibary/#adorneelibary-methods","text":"","title":"AdorneeLibary Methods"},{"location":"InfinityPages/InfinityLibaries/AdorneeLibary/#adorneelibarysphere","text":"","title":"AdorneeLibary.Sphere"},{"location":"InfinityPages/InfinityLibaries/AdorneeLibary/#adorneelibaryarrow","text":"","title":"AdorneeLibary.Arrow"},{"location":"InfinityPages/InfinityLibaries/HooksLibary/","text":"AdorneeLibary Methods AdorneeLibary.InvokeHook AdorneeLibary.BindHook","title":"Hooks"},{"location":"InfinityPages/InfinityLibaries/HooksLibary/#adorneelibary-methods","text":"","title":"AdorneeLibary Methods"},{"location":"InfinityPages/InfinityLibaries/HooksLibary/#adorneelibaryinvokehook","text":"","title":"AdorneeLibary.InvokeHook"},{"location":"InfinityPages/InfinityLibaries/HooksLibary/#adorneelibarybindhook","text":"","title":"AdorneeLibary.BindHook"},{"location":"InfinityPages/InfinityLibaries/IterLibary/","text":"IterLibary Methods IterLibary.new IterLibary.FromVararg IterObect IterObject Methods IterObject.Reset IterObject.GetKey IterObject.GetIndex IterObject.GetValue IterObject.Next","title":"Iter"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterlibary-methods","text":"","title":"IterLibary Methods"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterlibarynew","text":"","title":"IterLibary.new"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterlibaryfromvararg","text":"","title":"IterLibary.FromVararg"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobect","text":"","title":"IterObect"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobject-methods","text":"","title":"IterObject Methods"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobjectreset","text":"","title":"IterObject.Reset"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobjectgetkey","text":"","title":"IterObject.GetKey"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobjectgetindex","text":"","title":"IterObject.GetIndex"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobjectgetvalue","text":"","title":"IterObject.GetValue"},{"location":"InfinityPages/InfinityLibaries/IterLibary/#iterobjectnext","text":"","title":"IterObject.Next"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/","text":"MaidLibary Methods MaidLibary.new MaidObject IterObject Methods IterObject.Register IterObject.Remove IterObject.Clean","title":"Maid"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#maidlibary-methods","text":"","title":"MaidLibary Methods"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#maidlibarynew","text":"","title":"MaidLibary.new"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#maidobject","text":"","title":"MaidObject"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#iterobject-methods","text":"","title":"IterObject Methods"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#iterobjectregister","text":"","title":"IterObject.Register"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#iterobjectremove","text":"","title":"IterObject.Remove"},{"location":"InfinityPages/InfinityLibaries/MaidLibary/#iterobjectclean","text":"","title":"IterObject.Clean"},{"location":"InfinityPages/InfinityLibaries/MathLibary/","text":"MathLibary Methods MathLibary.VectorGrid MathLibary Plugins MathLibary Perlin Worm MathLibary Inverse Kinematics MathLibary Guid MathLibary Inheritance","title":"Math"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-methods","text":"","title":"MathLibary Methods"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibaryvectorgrid","text":"","title":"MathLibary.VectorGrid"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-plugins","text":"","title":"MathLibary Plugins"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-perlin-worm","text":"","title":"MathLibary Perlin Worm"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-inverse-kinematics","text":"","title":"MathLibary Inverse Kinematics"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-guid","text":"","title":"MathLibary Guid"},{"location":"InfinityPages/InfinityLibaries/MathLibary/#mathlibary-inheritance","text":"","title":"MathLibary Inheritance"},{"location":"InfinityPages/InfinityLibaries/NetLibary/","text":"NetLibary Properties NetLibary.Name NetLibary Objects NetLibary.Event NetLibary.Function NetLibary.Signal NetLibary.State","title":"Net"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibary-properties","text":"","title":"NetLibary Properties"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibaryname","text":"","title":"NetLibary.Name"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibary-objects","text":"","title":"NetLibary Objects"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibaryevent","text":"","title":"NetLibary.Event"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibaryfunction","text":"","title":"NetLibary.Function"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibarysignal","text":"","title":"NetLibary.Signal"},{"location":"InfinityPages/InfinityLibaries/NetLibary/#netlibarystate","text":"","title":"NetLibary.State"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/","text":"PromiseLibary Methods PromiseLibary.new PromiseLibary.Wrap PromiseLibary.IsPromise PromiseLibary.UntilSettled PromiseLibary.Any PromiseLibary.Race PromiseObject PromiseObject Methods PromiseObject.Reject PromiseObject.Resolve PromiseObject.Await PromiseObject.Cancel PromiseObject.Retry PromiseObject.Then PromiseObject.Catch PromiseObject.Finally PromiseObject.GetResult","title":"Promise"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibary-methods","text":"","title":"PromiseLibary Methods"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibarynew","text":"","title":"PromiseLibary.new"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibarywrap","text":"","title":"PromiseLibary.Wrap"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibaryispromise","text":"","title":"PromiseLibary.IsPromise"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibaryuntilsettled","text":"","title":"PromiseLibary.UntilSettled"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibaryany","text":"","title":"PromiseLibary.Any"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiselibaryrace","text":"","title":"PromiseLibary.Race"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobject","text":"","title":"PromiseObject"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobject-methods","text":"","title":"PromiseObject Methods"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectreject","text":"","title":"PromiseObject.Reject"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectresolve","text":"","title":"PromiseObject.Resolve"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectawait","text":"","title":"PromiseObject.Await"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectcancel","text":"","title":"PromiseObject.Cancel"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectretry","text":"","title":"PromiseObject.Retry"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectthen","text":"","title":"PromiseObject.Then"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectcatch","text":"","title":"PromiseObject.Catch"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectfinally","text":"","title":"PromiseObject.Finally"},{"location":"InfinityPages/InfinityLibaries/PromiseLibary/#promiseobjectgetresult","text":"","title":"PromiseObject.GetResult"},{"location":"InfinityPages/InfinityLibaries/ProxyLibary/","text":"ProxyLibary Objects ProxyLibary.FromTable","title":"Proxy"},{"location":"InfinityPages/InfinityLibaries/ProxyLibary/#proxylibary-objects","text":"","title":"ProxyLibary Objects"},{"location":"InfinityPages/InfinityLibaries/ProxyLibary/#proxylibaryfromtable","text":"","title":"ProxyLibary.FromTable"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/","text":"SignalLibary Methods SignalLibary.new SignalLibary.IsConnection SignalLibary.IsSignal ConnectionObject ConnectionObject.Destroy ConnectionObject.Disconnect ConnectionObject.Reconnect SignalObject SignalObject Methods SignalObject.Connect SignalObject.Wait SignalObject.Fire SignalObject.FireIn SignalObject.SetState SignalObject.Destroy","title":"Signal"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signallibary-methods","text":"","title":"SignalLibary Methods"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signallibarynew","text":"","title":"SignalLibary.new"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signallibaryisconnection","text":"","title":"SignalLibary.IsConnection"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signallibaryissignal","text":"","title":"SignalLibary.IsSignal"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#connectionobject","text":"","title":"ConnectionObject"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#connectionobjectdestroy","text":"","title":"ConnectionObject.Destroy"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#connectionobjectdisconnect","text":"","title":"ConnectionObject.Disconnect"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#connectionobjectreconnect","text":"","title":"ConnectionObject.Reconnect"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobject","text":"","title":"SignalObject"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobject-methods","text":"","title":"SignalObject Methods"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectconnect","text":"","title":"SignalObject.Connect"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectwait","text":"","title":"SignalObject.Wait"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectfire","text":"","title":"SignalObject.Fire"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectfirein","text":"","title":"SignalObject.FireIn"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectsetstate","text":"","title":"SignalObject.SetState"},{"location":"InfinityPages/InfinityLibaries/SignalLibary/#signalobjectdestroy","text":"","title":"SignalObject.Destroy"},{"location":"InfinityPages/InfinityLibaries/StateLibary/","text":"StateLibary Methods StateLibary.new StateObject StateObject Methods StateObject.Dec StateObject.Inc StateObject.Update StateObject.Set StateObject.Get","title":"State"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#statelibary-methods","text":"","title":"StateLibary Methods"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#statelibarynew","text":"","title":"StateLibary.new"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobject","text":"","title":"StateObject"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobject-methods","text":"","title":"StateObject Methods"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobjectdec","text":"","title":"StateObject.Dec"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobjectinc","text":"","title":"StateObject.Inc"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobjectupdate","text":"","title":"StateObject.Update"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobjectset","text":"","title":"StateObject.Set"},{"location":"InfinityPages/InfinityLibaries/StateLibary/#stateobjectget","text":"","title":"StateObject.Get"},{"location":"InfinityPages/InfinityLibaries/TableLibary/","text":"TableLibary Methods TableLibary.VectorGrid TableLibary Plugins TableLibary Dimentional TableLibary Utils TableLibary Inheritance","title":"Table"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibary-methods","text":"","title":"TableLibary Methods"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibaryvectorgrid","text":"","title":"TableLibary.VectorGrid"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibary-plugins","text":"","title":"TableLibary Plugins"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibary-dimentional","text":"","title":"TableLibary Dimentional"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibary-utils","text":"","title":"TableLibary Utils"},{"location":"InfinityPages/InfinityLibaries/TableLibary/#tablelibary-inheritance","text":"","title":"TableLibary Inheritance"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/","text":"TimerLibary Methods TimerLibary.new TimerObject TimerObject Methods TimerObject.Stop TimerObject.Start TimerObject.Continue TimerObject.GetTimeS TimerObject.GetTimeM TimerObject.GetTimeH TimerObject.GetTimeMS","title":"Timer"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerlibary-methods","text":"","title":"TimerLibary Methods"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerlibarynew","text":"","title":"TimerLibary.new"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobject","text":"","title":"TimerObject"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobject-methods","text":"","title":"TimerObject Methods"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectstop","text":"","title":"TimerObject.Stop"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectstart","text":"","title":"TimerObject.Start"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectcontinue","text":"","title":"TimerObject.Continue"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectgettimes","text":"","title":"TimerObject.GetTimeS"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectgettimem","text":"","title":"TimerObject.GetTimeM"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectgettimeh","text":"","title":"TimerObject.GetTimeH"},{"location":"InfinityPages/InfinityLibaries/TimerLibary/#timerobjectgettimems","text":"","title":"TimerObject.GetTimeMS"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/","text":"UtilsLibary Methods UtilsLibary.NewInstance UtilsLibary.CloneInstance UtilsLibary.InheritProperties UtilsLibary.WaitForChildOfType UtilsLibary.WaitForChildExtended","title":"Utils"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibary-methods","text":"","title":"UtilsLibary Methods"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibarynewinstance","text":"","title":"UtilsLibary.NewInstance"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibarycloneinstance","text":"","title":"UtilsLibary.CloneInstance"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibaryinheritproperties","text":"","title":"UtilsLibary.InheritProperties"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibarywaitforchildoftype","text":"","title":"UtilsLibary.WaitForChildOfType"},{"location":"InfinityPages/InfinityLibaries/UtilsLibary/#utilslibarywaitforchildextended","text":"","title":"UtilsLibary.WaitForChildExtended"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/","text":"InfinityConsole Methods InfinityConsole.GetCache InfinityConsole.Critical InfinityConsole.Error InfinityConsole.Warn InfinityConsole.Log","title":"Console"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsole-methods","text":"","title":"InfinityConsole Methods"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsolegetcache","text":"","title":"InfinityConsole.GetCache"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsolecritical","text":"","title":"InfinityConsole.Critical"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsoleerror","text":"","title":"InfinityConsole.Error"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsolewarn","text":"","title":"InfinityConsole.Warn"},{"location":"InfinityPages/InfinitySingletons/InfinityConsole/#infinityconsolelog","text":"","title":"InfinityConsole.Log"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/","text":"InfinityCoreGui Signals InfinityCoreGui.OnSetCore InfinityCoreGui Methods InfinityCoreGui.IsConsoleOpen InfinityCoreGui.IsMenuOpen InfinityCoreGui.IsEmoteMenuOpen InfinityCoreGui.IsInspectMenuOpen InfinityCoreGui.GetCore InfinityCoreGui.SetCore","title":"CoreGui"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoregui-signals","text":"","title":"InfinityCoreGui Signals"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguionsetcore","text":"","title":"InfinityCoreGui.OnSetCore"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoregui-methods","text":"","title":"InfinityCoreGui Methods"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguiisconsoleopen","text":"","title":"InfinityCoreGui.IsConsoleOpen"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguiismenuopen","text":"","title":"InfinityCoreGui.IsMenuOpen"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguiisemotemenuopen","text":"","title":"InfinityCoreGui.IsEmoteMenuOpen"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguiisinspectmenuopen","text":"","title":"InfinityCoreGui.IsInspectMenuOpen"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguigetcore","text":"","title":"InfinityCoreGui.GetCore"},{"location":"InfinityPages/InfinitySingletons/InfinityCoreGui/#infinitycoreguisetcore","text":"","title":"InfinityCoreGui.SetCore"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/","text":"InfinitySound Methods InfinitySound.LoadAssetFromID InfinitySound.RegisterSound InfinitySound.RegisterSounds SoundGroup SoundGroup Properties SoundGroup.PitchShift SoundGroup.Compressor SoundGroup.Tremolo SoundGroup.Flange SoundGroup.Reverb SoundGroup.Echo SoundGroup.Distortion SoundGroup.Chorus SoundGroup.Equalizer SoundGroup.SoundGroup SoundGroup Methods SoundGroup.AddSound SoundGroup.RemoveSound","title":"Sound"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#infinitysound-methods","text":"","title":"InfinitySound Methods"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#infinitysoundloadassetfromid","text":"","title":"InfinitySound.LoadAssetFromID"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#infinitysoundregistersound","text":"","title":"InfinitySound.RegisterSound"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#infinitysoundregistersounds","text":"","title":"InfinitySound.RegisterSounds"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroup","text":"","title":"SoundGroup"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroup-properties","text":"","title":"SoundGroup Properties"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgrouppitchshift","text":"","title":"SoundGroup.PitchShift"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupcompressor","text":"","title":"SoundGroup.Compressor"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgrouptremolo","text":"","title":"SoundGroup.Tremolo"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupflange","text":"","title":"SoundGroup.Flange"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupreverb","text":"","title":"SoundGroup.Reverb"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupecho","text":"","title":"SoundGroup.Echo"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupdistortion","text":"","title":"SoundGroup.Distortion"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupchorus","text":"","title":"SoundGroup.Chorus"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupequalizer","text":"","title":"SoundGroup.Equalizer"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupsoundgroup","text":"","title":"SoundGroup.SoundGroup"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroup-methods","text":"","title":"SoundGroup Methods"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupaddsound","text":"","title":"SoundGroup.AddSound"},{"location":"InfinityPages/InfinitySingletons/InfinitySound/#soundgroupremovesound","text":"","title":"SoundGroup.RemoveSound"}]}